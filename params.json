{"name":"Angular-meteor-todo","tagline":"Notes","body":"##Angular Templates in Meteor\r\n- angular-meteor package parses all .ng.html files and puts them in Angular's template cache with the id of their full path\r\n- when a .ng.html file is placed in /client, it is available to ng-include or ui-router as client/template.ng.html\r\n- all code in ng.html is compiled with Angular. Angular binds the data into the templates\r\n###HTML Files in Meteor define Templates\r\n- meteor parses all .HTML files and identifies three top-level tags: <head>,<body>, and <template>.\r\n- <template> is compiled into Meteor templates which can be referenced by HTML: {{> templateName}}, JS: Template.templateName.\r\n## Storing Tasks in a Collection\r\n- collections are meteors way of storing persistent data\r\n- collections can be accessed both server and client side\r\n- easy to write view logic without having to write a lot of server code\r\n- collections update themselves automatically, view will automatically display the most up-to-date data\r\n```javascript\r\n          MyCollection = new Mongo.Collection(\"my-collection\");\r\n          //SERVER: sets up MongoDB collection on\r\n          //CLIENT: creates a cache connection to the server collection\r\n```\r\n```javascript\r\n          // Create new Mongo Collection\r\n          Tasks = new Mongo.Collection('tasks');\r\n\r\n          if (Meteor.isClient) {\r\n\r\n            // This code only runs on the client\r\n            angular.module('simple-todos',['angular-meteor']);\r\n\r\n            angular.module('simple-todos').controller('TodosListCtrl', ['$scope', '$meteor',\r\n                function ($scope, $meteor) {\r\n                  // using #meteor service to bind Tasks collection to $scope.tasks\r\n                  // every change will be sunced in real time accross stack.\r\n                  $scope.tasks = $meteor.collection(Tasks);\r\n\r\n                }]);\r\n            }\r\n\r\n```\r\n###Inserting tasks from the console\r\n      opens a console into your app's local development database:\r\n        - meteor mongo\r\n        - db.tasks.insert({ text: \"Hello world!\", createdAt: new Date() });\r\n      - The browser will immediately update to show the new task.\r\n      - didn't have to write any code to connect the server-side database to our front-end code â€” it just happened automatically.\r\n##Adding Tasks With A form\r\n####  todos-list.ng.html:\r\n```javascript\r\n        <form class=\"new-task\" ng-submit=\"addTask(newTask); newTask='';\">\r\n        <input ng-model=\"newTask\" type=\"text\"\r\n             name=\"text\" placeholder=\"Type to add new tasks\" />\r\n        </form>\r\n\r\n```\r\nAttaching events to templates:\r\n  -  listening to the submit event on our form to call the addTask scope function and to reset the input field.\r\n#### simple-todos-angular.js:\r\n```javascript\r\n        $scope.addTask = function (newTask) {\r\n             $scope.tasks.push( {\r\n               text: newTask,\r\n               createdAt: new Date() }\r\n             );\r\n           };    \r\n```\r\nInserting into a collection:\r\n  - adding a task to the tasks collection by calling\r\n  ```javascript\r\n        $scope.tasks.push()\r\n```\r\n  - Being able to insert anything into the database from the client isn't very secure\r\n\r\n###Sorting our tasks\r\n- Angular sort filter can be used, use a different method because it is better for real world use cases.\r\n\r\n####  simple-todos-angular.js:\r\n```javascript\r\n  // Replace the Tasks collection variable with a function inside our $meteor.collection service call.\r\n  //function will return a the result of calling the find function with the sort parameter on our Tasks\r\n        $scope.tasks = $meteor.collection( function() {\r\n          return Tasks.find({}, { sort: { createdAt: -1 } })\r\n      });\r\n```\r\n##Checking off and Deleting Tasks\r\n```javascript\r\n        <ul ng-repeat=\"task in tasks\">\r\n            <li ng-class=\"{'checked': task.checked}\">\r\n              <button class=\"delete\" ng-click=\"tasks.remove(task)\">&times;</button>\r\n\r\n              <input type=\"checkbox\" ng-model=\"task.checked\" class=\"toggle-checked\" />\r\n\r\n              <span class=\"text\">{{task.text}}</span>\r\n            </li>\r\n          </ul>\r\n```\r\n  Update:\r\n    - bind the checked state of each task to a checkbox with Angular\r\n    - Meteor saves and syncs the stat across all clients. No code needed\r\n\r\n  Delete:\r\n    - tasks.remove(task): $meteor.collection helper remove takes an object or the id of an object and removes it from the database\r\n\r\n  Classes:\r\n    - bind the checked state of a task to a class with ng-class\r\n    - <li ng-class=\"{'checked': task.checked}\">\r\n      - if the checked property of a task is true, the checked class is added to our list item.\r\n\r\n#Running your app on Android or iOS\r\n- Angular needs the main document to be ready so it can bootstrap\r\n- different devices have different events for ready.\r\n- change the way we bootstrap our Angular app\r\n  - remove ng-app from the <body> (simple-todos-angular.html)\r\n  - simple-todos-angular.js Bootstrap Angular to mobile as well\r\n  ```javascript\r\n  function onReady() {\r\n    angular.bootstrap(document, ['simple-todos']);\r\n  }\r\n\r\n  if (Meteor.isCordova)\r\n    angular.element(document).on('deviceready', onReady);\r\n  else\r\n    angular.element(document).ready(onReady);\r\n  ```\r\n#Filtering collections\r\n- client-side data filtering feature users can check a box to see only incomplete tasks\r\n- Add hideComplete checkbox to template:\r\n```\r\n  <label class=\"hide-completed\">\r\n      <input type=\"checkbox\" ng-model=\"$parent.hideCompleted\"/>\r\n      Hide Completed Tasks\r\n    </label>\r\n\r\n  ```\r\n- checkbox binds to the scope's hideCompleted variable.\r\n- $parent creates a new child scope\r\n- update our $scope.tasks query each time hideCompleted changes.\r\n###\r\nFiltering collection syntax\r\n- query to return only the not completed todos looks like that:\r\n\r\n        Tasks.find({ checked: {$ne: true} }, { sort: { createdAt: -1 } })\r\n###Connecting Angular bindings to Meteor's reactivity\r\n- $scope.getReactively function that turns Angular scope variables into Meteor reactive variables.\r\n- Make query parameter reactive:\r\n  ```javascript\r\n        function ($scope, $meteor) {\r\n\r\n        $scope.tasks = $meteor.collection(function() {\r\n        return Tasks.find($scope.getReactively('query'), {sort: {createdAt: -1}})\r\n        });\r\n```\r\n####  Showing a count of incomplete tasks\r\n  ```javascript\r\n         $scope.incompleteCount = function () {\r\n                return Tasks.find({ checked: {$ne: true} }).count();\r\n              };\r\n  ```\r\n#Adding user accounts\r\n- accounts system and a drop-in login user interface that lets you add multi-user functionality to your app in minutes.\r\n-       meteor add accounts-ui accounts-password\r\n- Add Blaze loginButtons template to HTML:\r\n        <meteor-include src=\"loginButtons\"></meteor-include>\r\n-  meteor-include directive let's you add any Blaze template into your Angular templates.\r\n- loginButtons which is the Blaze template for user authentication flow supplied with the accounts-ui package.\r\n- add the following code to configure the accounts UI to use usernames instead of email addresses:\r\n```javascript\r\n        Accounts.ui.config({\r\n        passwordSignupFields: \"USERNAME_ONLY\"\r\n        });\r\n```\r\n- Only display the new task input field to logged in users\r\n  - Add owner and username to created task:\r\n```javascript\r\n        $scope.addTask = function(newTask) {\r\n        $scope.tasks.push( {\r\n            text: newTask,\r\n            createdAt: new Date(),             // current time\r\n            owner: Meteor.userId(),            // _id of logged in user\r\n            username: Meteor.user().username }  // username of logged in user\r\n        );\r\n        };\r\n\r\n```\r\n  - add an ng-show directive to only show the form when there is a logged in user:\r\n        <form class=\"new-task\"\r\n          ng-submit=\"addTask(newTask); newTask='';\"\r\n          ng-show=\"$root.currentUser\">\r\n  - add a statement to display the username field on each task:\r\n          <span class=\"text\">\r\n          <strong>{{task.username}}</strong> - {{task.text}}\r\n        </span>\r\n###Automatic accounts UI\r\n        - meteor add accounts-ui accounts-password\r\n        - <meteor-include src=\"loginButtons\"></meteor-include>\r\n###Getting information about the logged-in user\r\n        - {{$root.currentUser.username}} display the logged in user's username.\r\n        - Meteor.userId() to get the current user's id, or Meteor.user() to get the whole user document.\r\n###Custom templates\r\n  - You can choose not to use the accounts-ui package template and create your own Angular login templates.\r\n\r\n#Security with methods\r\n- any real application needs to control permissions for its data\r\n- declaring methods the best way to do this\r\n- instead of the client code directly calling insert, update, and remove, it will instead call methods that will check if the user is authorized to complete the action\r\n### Removing insecure\r\n- insecure package added by default.\r\n- package allows us to edit the database from the client.\r\n- remove this package:\r\n        meteor remove insecure\r\n### Defining methods\r\n- one method for each database operation we want to perform on the client.\r\n- Methods should be defined in code that is executed on the client and the server\r\n- Meteor Methods:\r\n```javascript\r\n        Meteor.methods({\r\n          addTask: function (text) {\r\n            // Make sure the user is logged in before inserting a task\r\n            if (! Meteor.userId()) {\r\n              throw new Meteor.Error('not-authorized');\r\n            }\r\n\r\n            Tasks.insert({\r\n              text: text,\r\n              createdAt: new Date(),\r\n              owner: Meteor.userId(),\r\n              username: Meteor.user().username\r\n            });\r\n          },\r\n          deleteTask: function (taskId) {\r\n            Tasks.remove(taskId);\r\n          },\r\n          setChecked: function (taskId, setChecked) {\r\n            Tasks.update(taskId, { $set: { checked: setChecked} });\r\n          }\r\n        });\r\n```\r\n- update the places we were operating on the collection to use the methods instead:\r\n  ```javascript    \r\n        $scope.addTask = function (newTask) {\r\n                $meteor.call('addTask', newTask);\r\n              };\r\n\r\n              $scope.deleteTask = function (task) {\r\n                $meteor.call('deleteTask', task._id);\r\n              };\r\n\r\n              $scope.setChecked = function (task) {\r\n                $meteor.call('setChecked', task._id, !task.checked);\r\n              };\r\n```\r\n-  handle the changes in the template:\r\n        <button class=\"delete\" ng-click=\"deleteTask(task)\">&times;</button>\r\n\r\n        <input type=\"checkbox\" ng-checked=\"task.checked\"\r\n             ng-click=\"setChecked(task)\" class=\"toggle-checked\" />\r\n####Why?\r\n1. When we insert tasks into the database, we can now securely verify that the user is logged in, that the createdAt field is correct, and that the owner and username fields are correct and the user isn't impersonating anyone.\r\n2. We can add extra validation logic to setChecked and deleteTask in later steps when users can make tasks private.\r\n3. Our client code is now more separated from our database logic. Instead of a lot of stuff happening inside our event handlers, we now have methods that can be called from anywhere.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}